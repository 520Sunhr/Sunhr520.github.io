<hr>
<p>title: codeforces 1335<br>date: 2020-4-13 22:35:00<br>categories:<br>    - codeforces<br>tags:<br>    - conceal</p>
<hr>
<p><a href="https://codeforces.com/contest/1335/problems" target="_blank" rel="noopener">原题链接</a><br>目录:<a href="#a">(</a><a href="#b">&gt;</a><a href="#c">_</a><a href="#d">&lt;</a><a href="#e">)</a><br><a name="a"></a></p>
<h2 id="A-Candies-and-Two-Sisters"><a href="#A-Candies-and-Two-Sisters" class="headerlink" title="A Candies and Two Sisters"></a>A Candies and Two Sisters</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个数，然后有多少整数 a, b 可以 a + b = n &amp;&amp; a &gt; b</p>
<h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>略</p>
<h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><pre><code class="cpp">frein(){
    <span class="function"><span class="keyword">int</span> <span class="title">in</span><span class="params">(n)</span></span>;
    <span class="built_in">cout</span> &lt;&lt; (n-n/<span class="number">2</span>)<span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;
}</code></pre>
<p><a name="b"></a></p>
<h2 id="B-Construct-the-String"><a href="#B-Construct-the-String" class="headerlink" title="B Construct the String"></a>B Construct the String</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你三个数 n, a, b你需要输出一个长度为 n 的字符串并且这个字符串需要满足:<br>    任何一个长度为a的连续子序列中有且仅有b种字母</p>
<h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>先搞出一组来，然后循环往右补</p>
<h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><pre><code class="cpp">frein(){
    <span class="function"><span class="keyword">int</span> <span class="title">innn</span><span class="params">(n, a, b)</span></span>;
    <span class="built_in">string</span> s;
    <span class="keyword">for</span>(<span class="keyword">char</span> i = <span class="string">'a'</span>; i &lt; <span class="string">'a'</span>+b; i++)
        s += i;
    <span class="keyword">char</span> c = s[s.size()<span class="number">-1</span>];
    <span class="keyword">for</span>(<span class="keyword">int</span> i = b; i &lt; a; i++)
        s += c;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = a; i &lt; n; i++){
        s += s[i - a];
    }
    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;
}</code></pre>
<p><a name="c"></a></p>
<h2 id="C-Two-Teams-Composing"><a href="#C-Two-Teams-Composing" class="headerlink" title="C Two Teams Composing##"></a>C Two Teams Composing##</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一组数, 你需要从这一组数中找出两组数目为x的数。这两组数要求:第一组各不相同的x的数，第二组数目相同的x个数</p>
<h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>找出数字一共多少种 king 和 每一种最大的数目 Max 之后判断一下输出</p>
<h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><pre><code class="cpp"><span class="keyword">int</span> book[N];


frein(){
    <span class="function"><span class="keyword">int</span> <span class="title">in</span><span class="params">(n)</span></span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++) book[i]=<span class="number">0</span>;
    fre(n){
        book[read()]++;
    }
    <span class="keyword">int</span> king = <span class="number">0</span>, Max = <span class="number">-1</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n+<span class="number">1</span>; i++){
        <span class="keyword">if</span>(book[i]) {
            king++;
            Max = max(Max, book[i]);
        }
    }
    <span class="keyword">int</span> ans = Max &lt; king ? Max : min(Max - <span class="number">1</span>, king);
    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;
}</code></pre>
<p><a name="d"></a></p>
<h2 id="D-Anti-Sudoku"><a href="#D-Anti-Sudoku" class="headerlink" title="D Anti-Sudoku"></a>D Anti-Sudoku</h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个正确的数独,你需要通过改数来达到下面的要求并输出</p>
<ul>
<li>任何一行有且仅有两个数相同</li>
<li>任何一列有且仅有两个数相同</li>
<li>3*3的区块中有且仅有两个数相同</li>
</ul>
<h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>将1~9的一个数换成1~9的另一个数即可</p>
<h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><pre><code class="cpp">frein()<span class="built_in">free</span>(<span class="number">9</span>,<span class="number">10</span>){
    <span class="keyword">char</span> t = getchar();
    <span class="keyword">if</span>(t == <span class="string">'9'</span>) <span class="built_in">putchar</span>(<span class="string">'1'</span>);
    <span class="keyword">else</span> <span class="built_in">putchar</span>(t);
}</code></pre>
<p><a name="e"></a></p>
<h2 id="E-Three-Blocks-Palindrome"><a href="#E-Three-Blocks-Palindrome" class="headerlink" title="E Three Blocks Palindrome"></a>E Three Blocks Palindrome</h2><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一组数，你需要输出满足要求的回文子序列的最大长度<br>子序列要求:<br>[a,a,…,a,b,b,…b,a,a,…a] 其中 左,右 有x个a，中间是y个b<br>其中 x, y均可为 0、 a, b可以为相同数字</p>
<h3 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h3><p>可以先找出左和右, 之后再找中间的部分<br>寻找左右:<br>    可以选择用一个数组book[N]存下每个数出现的位置<br>    那么从两端向中间选数即可<br>寻找中间:<br>    这就是找一个区间中出现次数最多的数，可以暴力，也可以用线段树等优化，个人倾向于暴力</p>
<p>特殊情况:<br>    左和右不存在(为0)的时候</p>
<h3 id="标程-4"><a href="#标程-4" class="headerlink" title="标程"></a>标程</h3><pre><code class="cpp"><span class="keyword">int</span> book[N][<span class="number">205</span>];
<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[<span class="number">205</span>];

frein(){
    <span class="function"><span class="keyword">int</span> <span class="title">in</span><span class="params">(n)</span></span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">205</span>; i++)
        v[i].clear();
    <span class="comment">//init</span>

    fre(n){
        <span class="function"><span class="keyword">int</span> <span class="title">in</span><span class="params">(t)</span></span>;
        v[t].push_back(_);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">205</span>; i++)
            book[_][i]=book[_<span class="number">-1</span>][i];
        book[_][t]++;
    }
    <span class="comment">//输入数据</span>

    <span class="keyword">int</span> Max = -INF;

    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">205</span>; i++)
        Max = max(Max, (<span class="keyword">int</span>)v[i].size());
    <span class="comment">//先找一下特殊情况</span>

    <span class="keyword">for</span>(<span class="keyword">int</span> _= <span class="number">0</span>; _&lt;<span class="number">205</span>; _++){

        <span class="keyword">int</span> cnt = v[_].size();
        <span class="keyword">if</span>(!cnt || cnt == <span class="number">1</span>) <span class="keyword">continue</span>; 
        <span class="comment">//当出现0或者1次的时候 不可能位于左右两端 舍弃</span>
        <span class="keyword">int</span> i = cnt/<span class="number">2</span> - <span class="number">1</span>, j = cnt - cnt/<span class="number">2</span>;
        <span class="comment">//我这里是从中间往边去，那么i, j应该选取中位数</span>
        <span class="comment">//奇数的时候 i = cnt/2 - 1，j = cnt/2 + 1</span>
        <span class="comment">//偶数的时候 i = cnt/2 - 1, j = cnt/2</span>
        <span class="comment">//综合这两种情况可推出 i = cnt/2 - 1, j = cnt - cnt / 2</span>
        <span class="comment">//此时 无需分奇偶</span>

        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>&amp;&amp;j &lt;= cnt){

            <span class="keyword">int</span> ans = <span class="number">2</span>*(i+<span class="number">1</span>);
            <span class="keyword">int</span> Tmax = <span class="number">0</span>;
            <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">205</span>; l++)
                <span class="keyword">if</span>(l!=_) Tmax = max(Tmax, book[v[_][j]][l]-book[v[_][i]<span class="number">-1</span>][l]);
            <span class="comment">//遍历区间内的每个数，找出出现次数最大的</span>

            Max = max(Max, ans+Tmax);

            i--,j++;
            <span class="comment">//i向左，j向右</span>
        }

    }
    <span class="built_in">cout</span> &lt;&lt; Max &lt;&lt; <span class="built_in">endl</span>;

}</code></pre>

<hr>
<p>title: Codeforces-Round-#638-(Div. 2)<br>date: 2020-05-02 06:39:44<br>tags:<br>    - conceal</p>
<hr>
<p><a href="#a">Phoenix and Balance</a>         15224<br><a href="#b">Phoenix and Beauty</a>          8929<br><a href="#c">Phoenix and Distribution</a>    5157<br><a href="#d">Phoenix and Science</a>            2459<br><a href="#e">Phoenix and Berries</a>            354<br><a href="#f">Phoenix and Memory</a>            113<br><img src="1348problems.png" alt="题目"><br><a name="a">Phoenix and Balance</a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个n，你需要从2,4,…,2^n中选出n/2个数，使得这n/2个数与剩下数的差的绝对值最小</p>
<h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>不难发现，前n-1项的和为2^n-2/。所以说我们需要选取这n/2个数在前n-1项中尽可能大，从而缩小与最后的差距</p>
<h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>{
    int in(n), ans = 1 &lt;&lt; n;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n/<span class="number">2</span>; i++) ans += <span class="number">1</span> &lt;&lt; i;
    <span class="built_in">cout</span> &lt;&lt; (ans &lt;&lt; <span class="number">1</span>)-(<span class="number">1</span>&lt;&lt;n+<span class="number">1</span>)+<span class="number">2</span> &lt;&lt;<span class="built_in">endl</span>;
}</code></pre>
<p><a name="b">Phoenix and Beauty</a></p>
<h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你n个数和k，你需要在这n个数中添加一些数，使得任何k个相连的和为一个定值</p>
<h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>通过数据范围(0&lt; n,k&lt;=10, ans&lt;=1e4)推测 答案可能是 n^2, 具体这道题就是可能是 n * n 、n * k、k * k中的<br>经过观测，显然n * k最靠谱， 已经有n个数了，那么我们只需要将每个数扩展到加以某些限定的k个数即可得到答案</p>
<h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>{
    <span class="function"><span class="keyword">int</span> <span class="title">inn</span><span class="params">(n, k)</span></span>; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi; <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; mib;
    fre(n) {<span class="function"><span class="keyword">int</span> <span class="title">in</span><span class="params">(k)</span></span>; <span class="keyword">if</span>(!mib[k]) vi.push_back(k); mib[k]=<span class="literal">true</span>;}
    <span class="keyword">if</span>(vi.size()&gt;k) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;
    <span class="keyword">else</span> {
        <span class="keyword">while</span>(vi.size() &lt;= k) vi.push_back(<span class="number">1</span>);
        <span class="built_in">cout</span> &lt;&lt; n*k &lt;&lt; <span class="built_in">endl</span>;
        <span class="built_in">free</span>(n, k)
            <span class="built_in">cout</span> &lt;&lt; vi[__<span class="number">-1</span>] &lt;&lt; <span class="string">" "</span>;
    } EN
}</code></pre>
<p><a name="c">Phoenix and Distribution</a></p>
<h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>你现在有一个字符串s，你可以把s的字符分到k个空的字符串a[i]中，s的每个字符只能分配给一个字符串。分配完之后你可以任意对a[i]重新排序，你需要找到一种分配方法使得分配之后的k个字符串中，字典序最大的字符串在所有方案中最小。</p>
<h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>通过数据范围推知，算法复杂度大概是O(n)或常熟较小的O(nlogn)<br>由于字典序，所以可以选择sort一下，然后根据结果分情况讨论</p>
<h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>{
    <span class="keyword">int</span> n, k; <span class="built_in">string</span> s; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; s; sort(all(s));
    <span class="keyword">if</span> (s[<span class="number">0</span>]!=s[k<span class="number">-1</span>]) <span class="built_in">cout</span> &lt;&lt; s[k<span class="number">-1</span>];
    <span class="keyword">else</span> <span class="keyword">if</span> (s[k]!=s[n<span class="number">-1</span>]) <span class="keyword">for</span> (<span class="keyword">int</span> i=k<span class="number">-1</span>; i&lt;n; i++) <span class="built_in">cout</span> &lt;&lt; s[i];
    <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i+=k) <span class="built_in">cout</span> &lt;&lt; s[i];
    EN
}</code></pre>
<p><a name="d">Phoenix and Science</a></p>
<h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你1个细胞，这个细胞白天可以有k个进行分裂，晚上重量每个会+1，你需要找出到达重量为n最少天数的方法</p>
<h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>因为要找最少的天数，首先考虑倍增。我们k天最多到达sum=1,2,4…2^(k-1)=2^k-1个。但是sum显然不能够直接等于 n， 会出现sum和n的差值，当我们sum最大的时候,差值dx最小<br>并且,dx一定小于最后一天细胞数目的两倍, 换句话说，期间总会有一天使得 x &lt; dx &lt; 2 * x, 这天先分裂一部分来处理差值次天分裂剩下的一部分<br>到sum是k天是倍增,处理差值1天,所以说最少k+1天</p>
<pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>{
    int in(n), sum; vector&lt;int&gt; vi;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; sum+i&lt;=n; i&lt;&lt;=<span class="number">1</span>)
        sum+=i, vi.push_back(i);
    <span class="keyword">if</span>(sum &lt; n) vi.push_back(n-sum);
    sort(all(vi)); <span class="built_in">cout</span> &lt;&lt; vi.size()<span class="number">-1</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vi.size(); i++)
        <span class="built_in">cout</span> &lt;&lt; vi[i]-vi[i<span class="number">-1</span>] &lt;&lt; <span class="string">" "</span>;
    EN
}</code></pre>
<p><a name="e"></a><br><a name="f"></a></p>

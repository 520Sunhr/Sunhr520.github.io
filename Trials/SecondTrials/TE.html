<hr>
<p>title: TE<br>date: 2020-2-16 15:16:17<br>categories:<br>    - Trials<br>tags:<br>    - conceal<br>mp3: <a href="http://domain.com/awesome.mp3" target="_blank" rel="noopener">http://domain.com/awesome.mp3</a></p>
<hr>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>有一个坐标系，BaoBao的家在(n, m)点，BaoBao现在在(0,0)点，坐标系上有k个奇怪的馅饼，
坐标分别为(x1,y1),(x2,y2)...(xk,yk)。
这k个馅饼的坐标满足任意i∈{2,3....,k}都有x(i-1) &lt;= xi, y(i-1)&lt;=yi，
BaoBao想要在回家的过程中将这k个馅饼拿到，同时还要保证走的步数最少，
BaoBao想要问聪明的你，他一共有几种走法？
答案对100003取模</code></pre><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>第一行一个整数T表示有T组测试数据。对于每组测试数据：
第一行包含三个整数n,m,k
接下来k 行每行两个整数(x,y)表示每个馅饼的坐标
1 &lt; T &lt; 10
0 &lt; n,m &lt; 1e18
0 &lt; k &lt; 1e5
0 &lt; x &lt; n
0 &lt; y &lt; m</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>对于每组测试数据输出一个整数，表示方案数</code></pre><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><pre><code>n x m 的地图，可以保证下一个总在上一个的 右下方
将相邻两个拿出来，就是 p x q 的地图从左上到右下的路
最终答案就是每相邻两个的乘积 </code></pre><h3 id="AC码"><a href="#AC码" class="headerlink" title="AC码"></a>AC码</h3><pre><code class="cpp"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="meta">#<span class="meta-keyword">define</span> INT_MAX 2147483647</span>
<span class="meta">#<span class="meta-keyword">define</span> INT_MIN (- INT_MAX - 1)</span>
<span class="meta">#<span class="meta-keyword">define</span> PI acos(-1)</span>

<span class="meta">#<span class="meta-keyword">define</span> in(x) (x) = read()</span>
<span class="meta">#<span class="meta-keyword">define</span> fre(x) for(int _=(x); _;_--)</span>
<span class="meta">#<span class="meta-keyword">define</span> frein() int in(Loop_var);while(Loop_var--)</span>

<span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>
<span class="function"></span>{
    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans = <span class="number">0</span>, mark = <span class="number">1</span>;
    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> t = getchar();
    <span class="keyword">while</span> (t &lt; <span class="string">'0'</span> || t &gt; <span class="string">'9'</span>)
    {
        <span class="keyword">if</span> (t == <span class="string">'-'</span>)
            mark = <span class="number">-1</span>;
        t = getchar();
    }
    <span class="keyword">while</span> (t &lt;= <span class="string">'9'</span> &amp;&amp; t &gt;= <span class="string">'0'</span>)
    {
        ans = (ans &lt;&lt; <span class="number">3</span>) + (ans &lt;&lt; <span class="number">1</span>) + t - <span class="string">'0'</span>;
        t = getchar();
    }

    <span class="keyword">return</span> ans * mark;
}

<span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> LL;

<span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">100003</span>;

<span class="keyword">int</span> jie[<span class="number">100003</span>], jiev[<span class="number">100003</span>];

<span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span>
<span class="function"></span>{
    <span class="keyword">int</span> res = <span class="number">1</span>;
    <span class="keyword">while</span> (k)
    {
        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k &gt;&gt;= <span class="number">1</span>;
    }
    <span class="keyword">return</span> res;
}

<span class="function">LL <span class="title">C</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>
<span class="function"></span>{
    <span class="keyword">if</span> (b &gt; a) <span class="keyword">return</span> <span class="number">0</span>;

    <span class="keyword">return</span> jie[a] * jiev[a - b] % p * jiev[b] % p;
}
<span class="comment">//数学公式求组合数 </span>

<span class="function"><span class="keyword">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b)</span></span>
<span class="function"></span>{
    <span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> C(a, b);
    <span class="keyword">return</span> (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
<span class="comment">//自行百度 </span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>
<span class="function"></span>{
    ios::sync_with_stdio(<span class="literal">false</span>);
    <span class="built_in">cin</span>.tie(<span class="number">0</span>);
    <span class="built_in">cout</span>.tie(<span class="number">0</span>);
    <span class="comment">//IO</span>

    jie[<span class="number">0</span>] = <span class="number">1</span>;
    jiev[<span class="number">0</span>] = <span class="number">1</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; p; i++)
    {
        jie[i] = <span class="number">1l</span>l * jie[i - <span class="number">1</span>] * i % p;
        jiev[i] = qmi(jie[i], p - <span class="number">2</span>) % p;
    }
    <span class="comment">//预处理 </span>

    frein()
    {
        LL in(m), in(n);

        LL ax = <span class="number">0</span>, ay = <span class="number">0</span>;
        LL bx = <span class="number">0</span>, by = <span class="number">0</span>;

        <span class="keyword">int</span> ans = <span class="number">1</span>;

        frein()
        {
            in(bx); in(by);

            ans *= lucas(by - ay + bx - ax, bx - ax);
            <span class="comment">//对于大树，用lucas求组合数 </span>

            ans %= p;

            ax = bx, ay = by;
        }

        ans *= lucas(n - by + m - bx, m - bx);

        <span class="built_in">cout</span> &lt;&lt; ans%p &lt;&lt; <span class="built_in">endl</span>;

    }

    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>

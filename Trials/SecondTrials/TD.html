<hr>
<p>title: TD<br>date: 2020-2-16 15:16:17<br>categories:<br>    - Trials<br>tags:<br>    - conceal<br>mp3: <a href="http://domain.com/awesome.mp3" target="_blank" rel="noopener">http://domain.com/awesome.mp3</a></p>
<hr>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre><code>有n个小朋友站成一排玩游戏，他们每个人手中分别有 a_1、a_2、a_3…a_n 
块石头，他们需要通过传递石头来调整手中的石头数目。每个人每次只能给相邻的人传递一块石头。他们不希望一个人拿着多个石头，但又想要让石头分布均匀，所以他们想要通过传递石头，使得每个人最多只拿1块石头，并且每个拿石头的人旁边的人都不拿石头，每个不拿石头的人旁边的人都拿石头。
你能告诉他们想要最少的传递次数吗？如果无法完成任务则输出−1</code></pre><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>第一行包含一个整数Ｔ表示Ｔ组测试数据，对于每组测试数据
第一行一个整数ｎ表示有ｎ个小朋友
第二行ｎ个数a1,a2....an表示开始时每个小朋友手中的石头个数
1 &lt; T &lt; 10
1 &lt; n &lt; 2e5
0 &lt; ai &lt; 1e9</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>对于每组测试样例输出一个数表示最小传递次数或-1</code></pre><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><pre><code>对于第一组测试样例:
2 0 0 0 -&gt; 1 1 0 0 -&gt; 1 0 1 0共需要传递两次
对于第二组测试样例:
0 2 0 0 -&gt; 0 1 1 0 -&gt; 0 1 0 1共需要传递两次</code></pre><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><pre><code>对于任何一种组合，最后只有三种可能：
1. 没有正确答案，及-1
2. 奇数位是 1 偶数位是 0
3. 偶数位是 1 奇数位是 0
由于 2 3 我们发现 石头数 
a. 人数偶数 石头数 为 人数的一半 
b. 人数奇数 石头数 为 人数的一半
    向上和向下两种情况 对应 3 2 
所以说，除上述两种情况，均为 1 
对于2 3直接模拟出来 

模拟思路:    
对于两种情况，每个人手中的结果不是 1 就是 0  
从左向右遍历，每次不够就借右边的，超出给右边 

但是这样可能会出现错误运算，比如
0 2 0 答案是 (1 0 1) 
但是按照上述规则 答案可能成为 (0 1 0) 1
后面那个不存在的同学拿着一个石头 
也有的时候会出现后面那个不存在的同学给出了一个不存在的石头 

所以我们还需要判断一下最后那位不存在的同学有没有接石头或借石头 </code></pre><h3 id="AC码"><a href="#AC码" class="headerlink" title="AC码"></a>AC码</h3><pre><code class="cpp"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="meta">#<span class="meta-keyword">define</span> INT_MAX 2147483647</span>
<span class="meta">#<span class="meta-keyword">define</span> INT_MIN (- INT_MAX - 1)</span>
<span class="meta">#<span class="meta-keyword">define</span> PI acos(-1)</span>

<span class="meta">#<span class="meta-keyword">define</span> in(x) (x) = read()</span>
<span class="meta">#<span class="meta-keyword">define</span> fre(x) for(int _=(x); _;_--)</span>
<span class="meta">#<span class="meta-keyword">define</span> frein() int in(Loop_var);while(Loop_var--)</span>

<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>
<span class="function"></span>{
    <span class="keyword">int</span> ans = <span class="number">0</span>, mark = <span class="number">1</span>;
    <span class="keyword">int</span> t = getchar();
    <span class="keyword">while</span> (t &lt; <span class="string">'0'</span> || t &gt; <span class="string">'9'</span>)
    {
        <span class="keyword">if</span> (t == <span class="string">'-'</span>)
            mark = <span class="number">-1</span>;
        t = getchar();
    }
    <span class="keyword">while</span> (t &lt;= <span class="string">'9'</span> &amp;&amp; t &gt;= <span class="string">'0'</span>)
    {
        ans = (ans &lt;&lt; <span class="number">3</span>) + (ans &lt;&lt; <span class="number">1</span>) + t - <span class="string">'0'</span>;
        t = getchar();
    }

    <span class="keyword">return</span> ans * mark;
}


<span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;
<span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> LL;
<span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ULL;

<span class="keyword">const</span> LL LL_MAX = (ULL) <span class="number">-1</span> &gt;&gt; <span class="number">1</span>;
<span class="keyword">const</span> LL LL_MIN = (ULL) <span class="number">-1</span> - LL_MAX;

LL peo[N];
LL tpeo[N];

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>
<span class="function"></span>{
    ios::sync_with_stdio(<span class="literal">false</span>);
    <span class="built_in">cin</span>.tie(<span class="number">0</span>);
    <span class="built_in">cout</span>.tie(<span class="number">0</span>);
    <span class="comment">//IO</span>

    frein()
    {
        <span class="function"><span class="keyword">int</span> <span class="title">in</span><span class="params">(n)</span></span>;

        LL sum = <span class="number">0</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)
        {
            in(peo[i]);
            <span class="comment">//输入第peo[i]手中的石头 </span>
            <span class="comment">//同时复制到 tpeo[i] 中 并 求和 </span>
            tpeo[i] = peo[i];
            sum += peo[i];
        }


        <span class="keyword">if</span>(sum &gt; (n + <span class="number">1</span>)/<span class="number">2</span> || sum &lt; n/<span class="number">2</span>) 
        {
            <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span>;
            <span class="keyword">continue</span>;
        }
        <span class="comment">//非正确答案直接输出 -1 </span>

        LL ans = <span class="number">0</span>;
        peo[n + <span class="number">1</span>] = <span class="number">0</span>;
        <span class="comment">//将第 n + 1个同学手中的石头清空 </span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)
        {

            <span class="keyword">if</span> (i &amp; <span class="number">1</span> &amp;&amp; peo[i] != <span class="number">1</span>)
            {
                LL k = peo[i] - <span class="number">1</span>;

                ans += k &lt; <span class="number">0</span> ? -k : k;
                peo[i] = <span class="number">1</span>;
                peo[i + <span class="number">1</span>] += k;
            }

            <span class="keyword">if</span>((i % <span class="number">2</span> == <span class="number">0</span>) &amp;&amp; peo[i])
            {
                ans += peo[i] &lt; <span class="number">0</span> ? -peo[i] : peo[i];
                peo[i + <span class="number">1</span>] += peo[i];
                peo[i] = <span class="number">0</span>;
            }

        }
        <span class="keyword">if</span>(peo[n + <span class="number">1</span>]) ans = LL_MAX;
        <span class="comment">//如果不存在的同学拿了石头或借了石头，舍弃 </span>

        <span class="comment">//再次模拟 </span>
        LL ansl = <span class="number">0</span>;
        tpeo[n + <span class="number">1</span>] = <span class="number">0</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)
        {
            <span class="keyword">int</span> t = i - <span class="number">1</span>;
            <span class="keyword">if</span> (t &amp; <span class="number">1</span> &amp;&amp; tpeo[i] != <span class="number">1</span>)
            {
                LL k = tpeo[i] - <span class="number">1</span>;

                ansl += k &lt; <span class="number">0</span> ? -k : k;
                tpeo[i] = <span class="number">1</span>;
                tpeo[i + <span class="number">1</span>] += k;
            }

            <span class="keyword">if</span> ((t % <span class="number">2</span> == <span class="number">0</span>) &amp;&amp; tpeo[i] != <span class="number">0</span>)
            {
                ansl += tpeo[i] &lt; <span class="number">0</span> ? -tpeo[i] : tpeo[i];
                tpeo[i + <span class="number">1</span>] += tpeo[i];
                tpeo[i] = <span class="number">0</span>;
            }

        }
        <span class="keyword">if</span>(tpeo[n + <span class="number">1</span>]) ansl = LL_MAX;

        <span class="built_in">cout</span> &lt;&lt; min(ans, ansl) &lt;&lt; <span class="built_in">endl</span>;

    }

    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
